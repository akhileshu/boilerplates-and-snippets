}))
.query(async ({ input }) => {
  const {
    query,
    category,
    brand,
    minPrice,
    maxPrice,
    inStock,
    sortBy,
    sortOrder,
    page,
    limit
  } = input;

  const skip = (page - 1) * limit;

  // Build where clause
  const where: any = {};

  // Text search across multiple fields
  if (query) {
    where.OR = [
      { name: { contains: query, mode: 'insensitive' } },
      { description: { contains: query, mode: 'insensitive' } },
      { brand: { contains: query, mode: 'insensitive' } },
      { tags: { has: query } }
    ];
  }

  // Filters
  if (category) where.category = category;
  if (brand && brand.length > 0) where.brand = { in: brand };
  if (minPrice !== undefined || maxPrice !== undefined) {
    where.price = {};
    if (minPrice !== undefined) where.price.gte = minPrice;
    if (maxPrice !== undefined) where.price.lte = maxPrice;
  }
  if (inStock !== undefined) where.inStock = inStock;

  // Execute query
  const [products, totalCount] = await Promise.all([
    prisma.product.findMany({
      where,
      orderBy: { [sortBy]: sortOrder },
      skip,
      take: limit,
    }),
    prisma.product.count({ where })
  ]);

  return {
    products,
    totalCount,
    totalPages: Math.ceil(totalCount / limit),